typedef struct
{
    float3 x;
    float3 y;
    float3 z;
} float3x3;

__CONSTANT__ float3x3 MATRIX_16 = {
    {-0.32119474, -0.23319618, -0.01719972},
    {-0.0910343 ,  0.44249129,  0.06447764},
    { 0.02945856, -0.10641155,  0.40821152}
};

__CONSTANT__ float3x3 MATRIX_INVERSE_16 = {
    {-2.70657868, -1.40060996,  0.10718864},
    {-0.56387056,  1.88543648, -0.32156592},
    { 0.04833176,  0.59256575,  2.35815011}
};

__CONSTANT__ float3x3 identity_matrix = {
    { 1.0f, 0.0f, 0.0f},
    { 0.0f, 1.0f, 0.0f},
    { 0.0f, 0.0f, 1.0f}
};

__CONSTANT__ float3x3 XYZ_to_LMS_CAT02 = {
    { 0.7328,  0.4296, -0.1624},
    {-0.7036,  1.6975,  0.0061},
    { 0.0030,  0.0136,  0.9834}
};

__CONSTANT__ float3x3 LMS_to_XYZ_CAT02 = {
    { 1.0961238208, -0.2788690002,  0.1827451794},
    { 0.4543690420,  0.4735331543,  0.0720978037},
    {-0.0096276087, -0.0056980312,  1.0153256400}
};

__CONSTANT__ float3x3 XYZ_to_AP0_ACES_matrix = {
    { 1.0498110175f,  0.0000000000f, -0.0000974845f},
    {-0.4959030231f,  1.3733130458f,  0.0982400361f},
    { 0.0000000000f,  0.0000000000f,  0.9912520182f}
};

__CONSTANT__ float3x3 AP0_ACES_to_XYZ_matrix = {
    { 0.9525523959f,  0.0000000000f,  0.0000936786},
    { 0.3439664498f,  0.7281660966f, -0.0721325464},
    { 0.0000000000f,  0.0000000000f,  1.0088251844}
};

__CONSTANT__ float3x3 panlrcm = {
    { 460.0f,  451.0f,  288.0f},
    { 460.0f, -891.0f, -261.0f},
    { 460.0f, -220.0f, -6300.0f},
};

// XYZ to sRGB matrix
__CONSTANT__ float3x3 XYZ_to_RGB_output = {
    {  3.2409699419f, -1.5373831776f, -0.4986107603f},
    { -0.9692436363f,  1.8759675015f,  0.0415550574f},
    {  0.0556300797f, -0.2039769589f,  1.0569715142f}
};

// sRGB to XYZ matrix
__CONSTANT__ float3x3 RGB_to_XYZ_output = {
    {  0.4123907993f,  0.3575843394f,  0.1804807884f},
    {  0.2126390059f,  0.7151686788f,  0.0721923154f},
    {  0.0193308187f,  0.1191947798f,  0.9505321522f}
};

// sRGB to XYZ matrix
__CONSTANT__ float3x3 RGB_to_XYZ_limit = {
    {  0.4123907993f,  0.3575843394f,  0.1804807884f},
    {  0.2126390059f,  0.7151686788f,  0.0721923154f},
    {  0.0193308187f,  0.1191947798f,  0.9505321522f}
};

__CONSTANT__ float PI = 3.141592653589793f;

__CONSTANT__ float L_A = 100.0f;

__CONSTANT__ float Y_b = 20.0f;

__CONSTANT__ float referenceLuminance = 100.0f;

// Chroma compress parameters
__CONSTANT__ float hoff = 0.835f;
__CONSTANT__ float hmul = 14.0f;
__CONSTANT__ float2 a = {-0.18f, -0.42f};
__CONSTANT__ float2 b = {0.135f, 0.13f};
__CONSTANT__ float2 c = {-0.08f, 0.0f};
__CONSTANT__ float chromaCompress = 1.0f;
__CONSTANT__ float2 chromaCompressParams = {2.1f, 0.85f};
__CONSTANT__ float3 shadowCompressParams = {0.54f, 0.13f, 0.54f};
__CONSTANT__ float sat = 1.2f;
__CONSTANT__ float shadow_boost = 1.195f;
// __CONSTANT__ float boundaryRGB = sstsLuminance.z / referenceLuminance;
__CONSTANT__ float boundaryRGB = 1.0f;

// DanieleEvoCurve (ACES2 candidate) parameters
__CONSTANT__ float mmScaleFactor = 100.0f;
__CONSTANT__ float daniele_n = 100.0f; // peak white  
__CONSTANT__ float daniele_n_r = 100.0f;    // Normalized white in nits (what 1.0 should be)
__CONSTANT__ float daniele_g = 1.15f;      // surround / contrast
__CONSTANT__ float daniele_c = 0.18f;      // scene-referred grey
__CONSTANT__ float daniele_c_d = 10.013f;    // display-referred grey (in nits)
__CONSTANT__ float daniele_w_g = 0.14f;    // grey change between different peak luminance
__CONSTANT__ float daniele_t_1 = 0.04f;     // shadow toe, flare/glare compensation - how ever you want to call it
__CONSTANT__ float daniele_r_hit_min = 128.0f;  // Scene-referred value "hitting the roof" at 100 nits
__CONSTANT__ float daniele_r_hit_max = 896.0f;  // Scene-referred value "hitting the roof" at 10,000 nits

__CONSTANT__ float3 surround = {0.9, 0.59, 0.9};

__CONSTANT__ float3 d65White = {95.05f, 100.0f, 108.88f};

// multiplies a 3D vector with a 3x3 matrix
__DEVICE__ float3 vector_dot( float3x3 m, float3 v)
{
    float3 r;

    r.x = m.x.x * v.x + m.x.y * v.y + m.x.z * v.z;
    r.y = m.y.x * v.x + m.y.y * v.y + m.y.z * v.z;
    r.z = m.z.x * v.x + m.z.y * v.y + m.z.z * v.z;
    
    return r;
}

// multiplies two 3x3 matrices together
__DEVICE__ float3x3 matrix_dot( float3x3 m1, float3x3 m2)
{
    float m00 = m1.x.x * m2.x.x + m1.x.y * m2.y.x + m1.x.z * m2.z.x;
    float m01 = m1.x.x * m2.x.y + m1.x.y * m2.y.y + m1.x.z * m2.z.y;
    float m02 = m1.x.x * m2.x.z + m1.x.y * m2.y.z + m1.x.z * m2.z.z;
    float m10 = m1.y.x * m2.x.x + m1.y.y * m2.y.x + m1.y.z * m2.z.x;
    float m11 = m1.y.x * m2.x.y + m1.y.y * m2.y.y + m1.y.z * m2.z.y;
    float m12 = m1.y.x * m2.x.z + m1.y.y * m2.y.z + m1.y.z * m2.z.z;
    float m20 = m1.z.x * m2.x.x + m1.z.y * m2.y.x + m1.z.z * m2.z.x;
    float m21 = m1.z.x * m2.x.y + m1.z.y * m2.y.y + m1.z.z * m2.z.y;
    float m22 = m1.z.x * m2.x.z + m1.z.y * m2.y.z + m1.z.z * m2.z.z;
    
    return float3x3{
        {m00, m01, m02},
        {m10, m11, m12},
        {m20, m21, m22}
    };
}

// "safe" power function to avoid NANs or INFs when taking a fractional power of a negative base
// this one initially returned -pow(abs(b), e) for negative b
// but this ended up producing undesirable results in some cases
// so now it just returns 0.0 instead
__DEVICE__ float spow( float base, float exponent )
{
    if(base < 0.0f && exponent != _floorf(exponent) )
    {
         return 0.0f;
    }
    else
    {
        return _powf(base, exponent); 
    }
}

__DEVICE__ float3 float3spow( float3 base, float exponent )
{
    return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));
}

__DEVICE__ float3 float3sign( float3 v )
{
    return make_float3(_copysignf(1.0f, v.x), _copysignf(1.0f, v.y), _copysignf(1.0f, v.z));
}

__DEVICE__ float3 float3abs( float3 a )
{
    return make_float3(_fabs(a.x), _fabs(a.y), _fabs(a.z));
}

// "safe" div
__DEVICE__ float sdiv( float a, float b )
{
	if(b == 0.0f)
	{
	    return 0.0f;
	}
	else
	{
	    return a / b;
	}
}

// convert radians to degrees
__DEVICE__ float degrees( float radians )
{
    return radians * 180.0f / PI;
}


// convert degrees to radians
__DEVICE__ float radians( float degrees )
{
    return degrees / 180.0f * PI;
}

__DEVICE__ float mod(float a, float N)
{
    return a - N * _floorf(a / N);
} 

// Don't think this is used
// __DEVICE__ float hue_angle( float a, float b )
// {
//     float h = degrees(_atan2f(b, a)) / 360.0f;
// 
//     return h;
// }

// Don't think this is used
// __DEVICE__ float achromatic_response_forward(float3 RGB)
// {
// 	float R = RGB.x;
// 	float G = RGB.y;
// 	float B = RGB.z;
// 
// 	float A = 2.0f * R + G + 0.05f * B - 0.305f;
// 
// 	return A;
// }

__DEVICE__ float3 compress(float3 xyz)
{
    float x = xyz.x;
    float y = xyz.y;
    float z = xyz.z;
   
    float C = (x + y + z) / 3.0f;
    if (C == 0.0f)
        return xyz;

    float R = _sqrtf(_powf((x-C), 2.0f) + _powf((y-C), 2.0f) + _powf((z-C), 2.0f));
    R = R * 0.816496580927726f; // np.sqrt(2/3)
    
    if (R != 0.0f)
    {
      x = (x - C) / R;
      y = (y - C) / R;
      z = (z - C) / R;
    }
      
    float r = R / C;
    float s = -_fminf(x, _fminf(y, z));
    
    float t = 0.0f;
    if (r != 0.0f)
    {
      t = (0.5f + spow((_powf((s - 0.5f), 2.0f) + _powf((_sqrtf(4.0f / _powf(r, 2.0f) + 1.0f) - 1.0f), 2.0f) / 4.0f), 0.5f));
      if (t == 0.0f)
        return float3(xyz.x, xyz.y, xyz.z);
      t = 1.0f / t;
    }

    x = C * x * t + C;
    y = C * y * t + C;
    z = C * z * t + C;

    return make_float3(x, y, z);
}

__DEVICE__ float3 uncompress(float3 xyz)
{
    float x = xyz.x;
    float y = xyz.y;
    float z = xyz.z;

    float C = (x+y+z)*(1.0f / 3.0f) ;
    if (C == 0.0f)
         return xyz;

    float R = _sqrtf(_powf((x-C), 2.0f) + _powf((y-C), 2.0f) + _powf((z-C), 2.0f));
    R = R * 0.816496580927726; // np.sqrt(2/3)
    
    if (R != 0.0f)
    {
		x = (x - C) / R;
		y = (y - C) / R;
		z = (z - C) / R;
    }

    float t = R / C;
    float s = -_fminf(x, _fminf(y, z));
    
    float r = 0.0f;
    if (t != 0.0f)
    {
         r = _sqrtf(_powf((2.0f * _sqrtf(_powf((1.0f / t - 0.5f),2.0f) - _powf((s - 0.5f), 2.0f)) + 1.0f), 2.0f) - 1.0f);
         if (r == 0.0f)
            return make_float3(xyz.x, xyz.y, xyz.z);
         r = 2.0f / r;
    }

    x = C * x * r + C;
    y = C * y * r + C;
    z = C * z * r + C;
    
    return make_float3(x, y, z);
}

// "PowerP" compression function (also used in the ACES Reference Gamut Compression)
// values of v above  'threshold' are compressed by a 'power' function
// so that an input value of 'limit' results in an output of 1.0
__DEVICE__ float compressPowerP( float v, float threshold, float limit, float power, int inverse )
{
    float s = (limit-threshold)/_powf(_powf((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);

    float vCompressed;

    if( inverse )
    {
        vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*_powf(-(_powf((v-threshold)/s,power)/(_powf((v-threshold)/s,power)-1.0f)),1.0f/power);
    }
    else
    {
        vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(_powf(1.0f+_powf((v-threshold)/s,power),1.0f/power));
    }

    return vCompressed;
}

// apply CAT02 chromatic adaptation to 'XYZ' from 'XYZ_ws' to 'XYZ_wd' white points
__DEVICE__ float3 apply_CAT02( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd )
{
    float3 LMS_ws = vector_dot(XYZ_to_LMS_CAT02, XYZ_ws);
    float3 LMS_wd = vector_dot(XYZ_to_LMS_CAT02, XYZ_wd);

    float3x3 Mscale = identity_matrix;
    Mscale.x.x = LMS_wd.x / LMS_ws.x;
    Mscale.y.y = LMS_wd.y / LMS_ws.y;
    Mscale.z.z = LMS_wd.z / LMS_ws.z;

    float3x3 M = matrix_dot(LMS_to_XYZ_CAT02, matrix_dot(Mscale, XYZ_to_LMS_CAT02));

    return vector_dot(M, XYZ);
}

__DEVICE__ float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)
{
	float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);
	float3 RGB_c;
	RGB_c.x = (400.0f * _copysignf(1.0f, RGB.x) * F_L_RGB.x) / (27.13f + F_L_RGB.x) + 0.1f;
	RGB_c.y = (400.0f * _copysignf(1.0f, RGB.y) * F_L_RGB.y) / (27.13f + F_L_RGB.y) + 0.1f;
	RGB_c.z = (400.0f * _copysignf(1.0f, RGB.z) * F_L_RGB.z) / (27.13f + F_L_RGB.z) + 0.1f;

	return RGB_c;
}

__DEVICE__ float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)
{
    float3 RGB_p =  (float3sign(RGB - 0.1f) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB - 0.1f)) / (400.0f - float3abs(RGB - 0.1f)), 1.0f / 0.42f) );

    return RGB_p;
}

__DEVICE__ float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w)
{
// 	float _X_w = XYZ_w.x ;
	float Y_w = XYZ_w.y ;
// 	float _Z_w = XYZ_w.z ;

	// # Step 0
	// # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.
	float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);

	// Ignore degree of adaptation.
	float D = 1.0f;

	// # Viewing conditions dependent parameters
	float k = 1.0f / (5.0f * L_A + 1.0f);
	float k4 = _powf(k,4);
	float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * _powf((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;
	float n = sdiv(Y_b, Y_w);
	float z = 1.48f + _sqrtf(n);

	// // float D_RGB = ( D[..., np.newaxis] * Y_w[..., np.newaxis] / RGB_w + 1 - D[..., np.newaxis] )
	float3 D_RGB = D * Y_w / RGB_w + 1.0f - D;
	float3 RGB_wc = D_RGB * RGB_w;

	// # Applying forward post-adaptation non-linear response compression.
	float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);

	// # Computing achromatic responses for the whitepoint.
	float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB) + 0.1f;

	// # Computing achromatic responses for the whitepoint.
	float R_aw = RGB_aw.x ;
	float G_aw = RGB_aw.y ;
	float B_aw = RGB_aw.z ;
	float A_w = 2 * R_aw + G_aw + 0.05f * B_aw - 0.305f;

	// # Step 1
	// # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.

	float3 RGB = vector_dot(MATRIX_16, XYZ);

	// # Step 2
	float3 RGB_c = D_RGB * RGB;

	// # Step 3
	// Always compressMode
	RGB_c = compress(RGB_c);

	float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);

	RGB_a = uncompress(RGB_a);

	// # Step 4
	// # Converting to preliminary cartesian coordinates.
	float R_a = RGB_a.x ;
	float G_a = RGB_a.y ;
	float B_a = RGB_a.z ;
	float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;
	float b = (R_a + G_a - 2.0f * B_a) / 9.0f;

	// # Computing the *hue* angle :math:`h`.
	// Unclear why this isnt matching the python version.
	float h = mod(degrees(_atan2f(b, a)), 360.0f);

	// # Step 6
	// # Computing achromatic responses for the stimulus.
	float R_a2 = RGB_a.x ;
	float G_a2 = RGB_a.y ;
	float B_a2 = RGB_a.z ;
	// A = 2 * R_a + G_a + 0.05 * B_a - 0.305
	float A = 2 * R_a2 + G_a2 + 0.05f * B_a2 - 0.305f;

	// # Step 7
	// # Computing the correlate of *Lightness* :math:`J`.
	// with sdiv_mode():
	float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);

	// # Step 8
	// # Computing the correlate of *brightness* :math:`Q`.
	// with sdiv_mode():
// 	float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;

	// # Step 9
	// # Computing the correlate of *colourfulness* :math:`M`.
	float M = 43.0f * surround.z * _sqrtf(a * a + b * b);

	// # Computing the correlate of *chroma* :math:`C`.
	// with sdiv_mode():
// 	float C = 35.0f * sdiv(M, A_w);

	// Np *Helmholtz–Kohlrausch* Effect Extension.


	if (J == 0.0f)
	{
		M = 0.0f;
	}
	  return make_float3(J, M, h);
}

__DEVICE__ float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w)
{
	float J = JMh.x;
	float M = JMh.y;
	float h = JMh.z;

//         float _X_w = XYZ_w.x;
	float Y_w = XYZ_w.y;
//         float _Z_w = XYZ_w.z;

	// # Step 0
	// # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.
	float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);

	// Ignore degree of adaptation.
	float D = 1.0f;

	// # Viewing conditions dependent parameters
	float k = 1.0f / (5.0f * L_A + 1.0f);
	float k4 = _powf(k, 4.0f);
	float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * _powf((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;
	float n = sdiv(Y_b, Y_w);
	float z = 1.48f + _sqrtf(n);

	// // float D_RGB = ( D[..., np.newaxis] * Y_w[..., np.newaxis] / RGB_w + 1 - D[..., np.newaxis] )
	float3 D_RGB = D * Y_w / RGB_w + 1.0f - D;
	float3 RGB_wc = D_RGB * RGB_w;

	// # Applying forward post-adaptation non-linear response compression.
	float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);

	// # Computing achromatic responses for the whitepoint.
	float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB) + 0.1f;

	// # Computing achromatic responses for the whitepoint.
	float R_aw = RGB_aw.x ;
	float G_aw = RGB_aw.y ;
	float B_aw = RGB_aw.z ;
	float A_w = 2.0f * R_aw + G_aw + 0.05f * B_aw - 0.305f;

	float hr = radians(h);

	// No *Helmholtz–Kohlrausch* Effect.

	// # Computing achromatic response :math:`A` for the stimulus.
	float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));

	// # Computing *P_p_1* to *P_p_2*.
	float P_p_1 = 43.0f * surround.z;
	float P_p_2 = A;


	// # Step 3
	// # Computing opponent colour dimensions :math:`a` and :math:`b`.
	// with sdiv_mode():
	float gamma = M / P_p_1;

	float a = gamma * _cosf(hr);
	float b = gamma * _sinf(hr);


	// # Step 4
	// # Applying post-adaptation non-linear response compression matrix.

	float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;

	// # Step 5
	// # Applying inverse post-adaptation non-linear response compression.

	// Always compressMode
	RGB_a = compress(RGB_a);

	float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a + 0.1, F_L);

	RGB_c = uncompress(RGB_c);

	// # Step 6
	float3 RGB = RGB_c / D_RGB;
	

	// # Step 7
	float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);

	return XYZ;
}

// convert JMh correlates to  RGB values in the output colorspace
__DEVICE__ float3 JMh_to_luminance_RGB(float3 JMh)
{
	float3 luminanceXYZ = Hellwig2022_JMh_to_XYZ( JMh, d65White);
	float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);

	return luminanceRGB;
}

// convert RGB values in the output colorspace to the ZCAM J (lightness), M (colorfulness) and h (hue) correlates
float3 luminance_RGB_to_JMh(float3 luminanceRGB)
{
    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);
    float3 JMh = XYZ_to_Hellwig2022_JMh(XYZ, d65White);
    return JMh;
}

__DEVICE__ float daniele_evo_fwd(float Y)
{
    const float daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));
    const float daniele_m_0 = daniele_n / daniele_n_r;
    const float daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));
    const float daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);
    const float daniele_m = daniele_m_1 / daniele_u;
    const float daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);
    const float daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;
    const float daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));
    const float daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);
    const float daniele_w_2 = daniele_c / daniele_g_ipp2;
    const float daniele_s_2 = daniele_w_2 * daniele_m_1;
    const float daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);
    const float daniele_m_2 = daniele_m_1 / daniele_u_2;

    float f = daniele_m_2 * _powf(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);
    float h = max(0.0f, f * f / (f + daniele_t_1));

    return h;
}

__DEVICE__ float ptanh(float x, float p, float t, float pt)
{
    return _powf(_tanhf(_powf(x, p) / t), 1.0f / pt);
}

// convert linear RGB values with the limiting primaries to ZCAM J (lightness), M (colorfulness) and h (hue) correlates
__DEVICE__ float3 limit_RGB_to_JMh(float3 RGB)
{
    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;
    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);
    float3 JMh = XYZ_to_Hellwig2022_JMh(XYZ, d65White);
    return JMh;
}

// Scaled power(p)
__DEVICE__ float spowerp(float x, float l, float p)
{
    x = x / l;
    x = x != 0.0f ? x / pow(1.0f + spow(x, p), 1.0f / p) : 0.0f;
    return x * l;
}

__DEVICE__ float desat_curve(float x)
  {
    float m = daniele_n / daniele_n_r;
    float w = 1.18f * m;
    return (_fmaxf(0.0f, x) / (x + w)) * m;
  }

  // Hue-dependent curve used in chroma compression
  // https://www.desmos.com/calculator/lmbbu8so4c
__DEVICE__ float compr_hue_depend(float h)
  {
    float hr = radians(h);
    float hr2 = hr * 2.0f;
    float hr3 = hr * 3.0f;

    return (a.x * _cosf(hr) +
            b.x * _cosf(hr2) +
            c.x * _cosf(hr3) +
            a.y * _sinf(hr) +
            b.y * _sinf(hr2) +
            c.y * _sinf(hr3) +
            hoff) * hmul;
  }

  // Chroma compression
  //
  // - Compresses the scene colorfulness with desat_curve() and spowerp() for
  //   path-to-white and path-to-black.
  // - Scales the colorfulness with a cubic curve to affect the rate of change of
  //   desaturation as lightness is increased.  This is hue dependent and affects
  //   a range of colorfulness (distance from the achromatic).
  //
__DEVICE__ float chromaCompression(float3 JMh, float luminance, int invert)
  {
    float M = JMh.y;
    
    // limitJmax (asumed to match limitRGB white)
    float limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;

    // Model specific factors to avoid having to change parameters manually
    int camMode = 1;
    float model_desat_factor = camMode == 1 ? chromaCompress * 1.22f : chromaCompress * 0.8f;
    float model_factor = camMode == 1 ? 5.0f : 1.0f;

    // Path-to-white
    //
    // Compression curve based on the difference of the scene luminance and desat_curve().
    // This scales automatically, compressing less with higher peak luminance.  Higher peak
    // luminance has a slower rate of change for colorfulness so it needs less compression.
    // The end variable can be used to affect how close to white point the curve ends, and
    // prevents the curve ever going negative.
    // https://www.desmos.com/calculator/ovy5wzr7lm
    //
    float end = 0.12f;
    float x = _log10f(luminance) - _log10f(desat_curve(luminance));
    model_desat_factor += _logf(daniele_n / daniele_n_r) * 0.08f;
    float desatcurve = spowerp(x * model_desat_factor, chromaCompressParams.x, chromaCompressParams.y);
    desatcurve = desatcurve < (1.0f - end) ? desatcurve : (1.0f - end) + end * _tanhf((desatcurve - (1.0f - end)) / end);

    // Path-to-black
    //
    // Shadow compression to reduce clipping and colorfulness of noise.
    // https://www.desmos.com/calculator/ovy5wzr7lm
    //
    float shadowcurve = ptanh(luminance, shadowCompressParams.x, shadowCompressParams.y, shadowCompressParams.z);

    // In-gamut compression
    //
    // Hue-dependent compression of M with R (J) from achromatic outward.  The purpose is to make sure
    // the interior of the gamut is smooth and even.  Larger values of R will compress larger range of
    // colorfulness.  The c variable controls compression with R (1.0 no compression, 0.0001 full
    // compression).  The driver is the tonescaled lightness in 0-1 range.  The shadow_boost affects
    // saturation mainly at and under normal exposure.
    // https://www.desmos.com/calculator/nygtri388c
    //
    float R = (JMh.x + 0.01f) * model_factor * compr_hue_depend(JMh.z);
    float c = max(1.0f - (JMh.x / limitJmax), 0.0001f) * shadow_boost;

    desatcurve = (1.0f - desatcurve) * shadowcurve;

    if (!invert)
    {
      M *= desatcurve;
      if (M != 0.0f && R != 0.0f)
      {
        M *= ((M * M + R * c) / (M * M + R));
      }
      M *= sat;
    }
    else
    {
      M /= sat;
      if (M != 0.0f && R != 0.0f)
      {
        float t0 = 3.0f * R * c;
        float p0 = M * M - t0;
        float p1 = 2.0f * M * M + 27.0f * R - 3.0f * t0;
        float p2 = spow((sqrt(M * M * p1 * p1 - 4.0f * p0 * p0 * p0) / 2.0f) + M * p1 / 2.0f, 1.0f / 3.0f);
        M = (p0 / (3.0f * p2) + (p2 / 3.0f) + (M / 3.0f));
      }
      M /= desatcurve;
    }

    return M;
  }

__DEVICE__ float3 forwardTonescale( float3 inputJMh)
{
    float3 outputJMh;
    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);
    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);
    float linear = linearJMh.x / referenceLuminance;

    // only Daniele Evo tone scale
    float luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;

    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));
    float3 tonemappedJMh = float3(tonemappedmonoJMh.x, inputJMh.y, inputJMh.z);

    outputJMh = tonemappedJMh;

    // Chroma Compression)
    outputJMh.y = chromaCompression(outputJMh, linear, 0);

    return outputJMh;
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B)
{
    float3 in = make_float3(p_R, p_G, p_B);
    
    float3 out = 100.0f * in;
    out = vector_dot(AP0_ACES_to_XYZ_matrix, out);
    out = XYZ_to_Hellwig2022_JMh(out, d65White);
    out = forwardTonescale(out);
    out = Hellwig2022_JMh_to_XYZ(out , d65White) / 100.0f;
    out = vector_dot(XYZ_to_RGB_output, out);
    out = float3spow(out, 1.0f / 2.4f);

    return out ;
}