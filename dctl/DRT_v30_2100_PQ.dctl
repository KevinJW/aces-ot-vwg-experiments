DEFINE_UI_PARAMS(toneCurve, Tone Curve, DCTLUI_CHECK_BOX, 1)
DEFINE_UI_PARAMS(compressChroma, Compress Chroma, DCTLUI_CHECK_BOX, 1)
DEFINE_UI_PARAMS(gamutCompress, Gamut Compress, DCTLUI_CHECK_BOX, 1)
DEFINE_UI_PARAMS(JMhOut, Diagnostic JMh Output, DCTLUI_CHECK_BOX, 0)

typedef struct
{
    float3 x;
    float3 y;
    float3 z;
} float3x3;
// Matrices calculated from {4200, -1050} white point used in Blink v30
// __CONSTANT__ float3x3 MATRIX_16 = {
//     {-0.32119474f, -0.23319618f, -0.01719972f},
//     {-0.0910343f ,  0.44249129f,  0.06447764f},
//     { 0.02945856f, -0.10641155f,  0.40821152f}
// };

// __CONSTANT__ float3x3 MATRIX_INVERSE_16 = {
//     {-2.70657868f, -1.40060996f,  0.10718864f},
//     {-0.56387056f,  1.88543648f, -0.32156592f},
//     { 0.04833176f,  0.59256575f,  2.35815011f}
// };

// Matrices calculated from Equal Energy white
__CONSTANT__ float3x3 MATRIX_16 = {
    { 0.56193142f,  0.40797761f,  0.03009097f},
    {-0.21886684f,  1.06384814f,  0.15501869f},
    { 0.08892922f, -0.32123412f,  1.2323049f }
};

__CONSTANT__ float3x3 MATRIX_INVERSE_16 = {
    { 1.54705503, -0.58256219,  0.03550715},
    { 0.32230313,  0.78421833, -0.10652146},
    {-0.02762598,  0.24646862,  0.78115737}
};

// Input matrix
__CONSTANT__ float3x3 AP0_ACES_to_XYZ_matrix = {
    { 0.9525523959f,  0.0000000000f,  0.0000936786},
    { 0.3439664498f,  0.7281660966f, -0.0721325464},
    { 0.0000000000f,  0.0000000000f,  1.0088251844}
};

// Matrix for Hellwig inverse
__CONSTANT__ float3x3 panlrcm = {
    { 460.0f,  451.0f,  288.0f},
    { 460.0f, -891.0f, -261.0f},
    { 460.0f, -220.0f, -6300.0f},
};

__CONSTANT__ float3x3 XYZ_to_RGB_output = {
// XYZ to sRGB matrix
//     {  3.2409699419f, -1.5373831776f, -0.4986107603f},
//     { -0.9692436363f,  1.8759675015f,  0.0415550574f},
//     {  0.0556300797f, -0.2039769589f,  1.0569715142f}
// XYZ to BT.2020 matrix
    {  1.7166511880f, -0.3556707838f, -0.2533662814f},
    { -0.6666843518f,  1.6164812366f,  0.0157685458f},
    {  0.0176398574f, -0.0427706133f,  0.9421031212f}
};

__CONSTANT__ float3x3 RGB_to_XYZ_output = {
// sRGB to XYZ matrix
//     {  0.4123907993f,  0.3575843394f,  0.1804807884f},
//     {  0.2126390059f,  0.7151686788f,  0.0721923154f},
//     {  0.0193308187f,  0.1191947798f,  0.9505321522f}
// BT.2020 to XYZ matrix
    {  0.6369580483f,  0.1446169036f,  0.1688809752f},
    {  0.2627002120f,  0.6779980715f,  0.0593017165f},
    {  0.0000000000f,  0.0280726930f,  1.0609850577f}
};

__CONSTANT__ float3x3 RGB_to_XYZ_limit = {
// sRGB to XYZ matrix
//     {  0.4123907993f,  0.3575843394f,  0.1804807884f},
//     {  0.2126390059f,  0.7151686788f,  0.0721923154f},
//     {  0.0193308187f,  0.1191947798f,  0.9505321522f}
// P3-D65 to XYZ matrix
    {  0.4865709486f,  0.2656676932f,  0.1982172852f},
    {  0.2289745641f,  0.6917385218f,  0.0792869141f},
    { -0.0000000000f,  0.0451133819f,  1.0439443689f}
};

__CONSTANT__ float PI = 3.141592653589793f;

__CONSTANT__ float L_A = 100.0f;

__CONSTANT__ float Y_b = 20.0f;

__CONSTANT__ float referenceLuminance = 100.0f;

// Chroma compress parameters
__CONSTANT__ float hoff = 0.835f;
__CONSTANT__ float hmul = 14.0f;
__CONSTANT__ float2 a = {-0.18f, -0.42f};
__CONSTANT__ float2 b = {0.135f, 0.13f};
__CONSTANT__ float2 c = {-0.08f, 0.0f};
__CONSTANT__ float chromaCompress = 1.0f;
__CONSTANT__ float2 chromaCompressParams = {2.1f, 0.85f};
__CONSTANT__ float3 shadowCompressParams = {0.54f, 0.121f, 0.545f}; // 0.121 = max(0.121, 0.132 - 0.00002 * parent.ssts_luminance.z)
__CONSTANT__ float sat = 1.2f;
__CONSTANT__ float shadow_boost = 1.08f; // max(1.08, 1.21 - 0.00015 * parent.ssts_luminance.z)
// __CONSTANT__ float boundaryRGB = sstsLuminance.z / referenceLuminance;
// __CONSTANT__ float boundaryRGB = 10.0f;
// limitJmax (asumed to match limitRGB white)
// float limitJmax = limit_RGB_to_JMh(make_float3(1.0f, 1.0f, 1.0f)).x;
__CONSTANT__ float limitJmax = 283.3f;

// DanieleEvoCurve (ACES2 candidate) parameters
__CONSTANT__ float mmScaleFactor = 100.0f;
__CONSTANT__ float daniele_n = 1000.0f; // peak white  
__CONSTANT__ float daniele_n_r = 100.0f;    // Normalized white in nits (what 1.0 should be)
__CONSTANT__ float daniele_g = 1.15f;      // surround / contrast
__CONSTANT__ float daniele_c = 0.18f;      // scene-referred grey
__CONSTANT__ float daniele_c_d = 10.013f;    // display-referred grey (in nits)
__CONSTANT__ float daniele_w_g = 0.14f;    // grey change between different peak luminance
__CONSTANT__ float daniele_t_1 = 0.04f;     // shadow toe, flare/glare compensation - how ever you want to call it
__CONSTANT__ float daniele_r_hit_min = 128.0f;  // Scene-referred value "hitting the roof" at 100 nits
__CONSTANT__ float daniele_r_hit_max = 896.0f;  // Scene-referred value "hitting the roof" at 10,000 nits

// Gamut Compression parameters
__CONSTANT__ float cuspMidBlend = 0.8f;
__CONSTANT__ float smoothCusps = 0.0f;
__CONSTANT__ float midJ = 34.08f; // ~10 nits in Hellwig J
__CONSTANT__ float focusDistance = 2.0f;
__CONSTANT__ float4 compressionFuncParams = {0.75f, 1.2f, 1.45f, 1.0f};
// __CONSTANT__ float gamut_gamma = 1.137f; // surround.y * (1.48 + sqrt(Y_b / Y_w)))
__CONSTANT__ float gamut_gamma = 0.879464f; // reciprocal of above
// cusp values calculated using Python in https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/d94d1d3b8891fcbd134d417d3374ecdffb4016e9/python/cusp_path.py
// (resulting values saved in ./data/J_cusp_BT709.txt and ./data/M_cusp_BT709.txt)
__CONSTANT__ float2 gamutCuspTable[360] = {
{174.3, 247.87494090},
{173.8, 247.24994105},
{173.2, 246.49994123},
{172.6, 245.74994141},
{172.1, 245.03236887},
{171.4, 244.24994177},
{170.8, 243.49994195},
{170.1, 242.62494215},
{169.4, 241.74994236},
{168.7, 240.87494257},
{167.9, 239.87494281},
{167.1, 238.87494305},
{166.3, 237.87494329},
{165.4, 236.74994355},
{164.6, 235.68530554},
{163.7, 234.57616529},
{162.8, 233.39249980},
{161.8, 232.24994463},
{160.9, 231.08152255},
{159.9, 229.87494519},
{158.9, 228.62494549},
{158.0, 227.40166247},
{157.0, 226.19492501},
{156.0, 224.97720122},
{155.0, 223.74994665},
{154.0, 222.49994695},
{154.6, 218.67242926},
{155.9, 213.83842668},
{157.1, 209.26927438},
{158.4, 204.99611950},
{159.6, 200.95503795},
{160.7, 197.14244589},
{161.9, 193.56127062},
{163.0, 190.17338604},
{164.1, 186.95472041},
{165.2, 183.86688864},
{166.2, 180.98940271},
{167.3, 178.22512063},
{168.3, 175.65433797},
{169.3, 173.19471994},
{170.3, 170.84102938},
{171.2, 168.64535809},
{172.2, 166.56501299},
{173.1, 164.55441222},
{174.1, 162.65415898},
{175.0, 160.89097649},
{175.9, 159.20405576},
{176.8, 157.59317660},
{177.7, 156.06806943},
{178.6, 154.60697597},
{179.4, 153.21925825},
{180.3, 151.95044598},
{181.2, 150.75474536},
{182.0, 149.56651270},
{182.9, 148.51663503},
{183.8, 147.47026974},
{184.6, 146.54710454},
{185.4, 145.62411135},
{186.3, 144.82892624},
{187.1, 144.02586123},
{188.0, 143.31714272},
{188.8, 142.65438986},
{189.6, 142.01759934},
{190.5, 141.49664417},
{191.3, 140.96270642},
{192.2, 140.51459545},
{193.0, 140.10521561},
{193.9, 139.73506686},
{194.7, 139.43649897},
{195.6, 139.16422713},
{196.4, 138.94932997},
{197.3, 138.80206570},
{198.2, 138.64143938},
{199.0, 138.57675880},
{199.9, 138.55764410},
{200.8, 138.58010650},
{201.7, 138.64416310},
{202.6, 138.74955231},
{203.5, 138.89599964},
{204.4, 139.08362615},
{205.4, 139.36482459},
{206.3, 139.63952342},
{207.3, 140.00790498},
{208.3, 140.38641360},
{209.3, 140.81817546},
{210.3, 141.32317266},
{211.3, 141.89605060},
{212.3, 142.47360066},
{213.4, 143.15154558},
{214.5, 143.84341612},
{215.6, 144.61381161},
{216.7, 145.45104504},
{217.8, 146.30863667},
{219.0, 147.27079868},
{220.2, 148.28102589},
{221.5, 149.34461117},
{222.7, 150.50876141},
{224.0, 151.72884464},
{225.4, 153.00614834},
{226.7, 154.38988209},
{228.1, 155.83426952},
{229.6, 157.39610195},
{231.1, 159.01944637},
{232.7, 160.75637341},
{234.3, 162.57770061},
{236.0, 164.47041035},
{237.7, 166.53106213},
{239.5, 168.67868900},
{241.4, 170.96550465},
{243.3, 173.33500385},
{244.5, 175.33285618},
{243.3, 176.00619793},
{242.1, 176.71144009},
{240.9, 177.48205662},
{239.8, 178.33378315},
{238.6, 179.28164005},
{237.4, 180.27269840},
{236.2, 181.31153584},
{235.0, 182.39529133},
{233.7, 183.60550404},
{232.5, 184.90040302},
{231.2, 186.21346951},
{230.0, 187.68460751},
{228.7, 189.17977810},
{227.4, 190.77193737},
{226.1, 192.46551991},
{224.8, 194.26553249},
{223.5, 196.17755413},
{222.1, 198.13134670},
{220.7, 200.20687580},
{219.3, 202.41100788},
{217.9, 204.75132465},
{216.5, 207.23583698},
{215.0, 209.79013711},
{213.5, 212.50427142},
{212.0, 215.34022927},
{210.4, 218.36579061},
{208.8, 221.53353810},
{207.2, 224.81970906},
{205.5, 228.38033840},
{203.8, 232.03467375},
{202.0, 236.00800574},
{200.2, 240.10612839},
{201.5, 237.20024422},
{202.9, 233.82591262},
{204.3, 230.55097881},
{205.7, 227.43341032},
{207.0, 224.33622390},
{208.2, 221.34082800},
{209.4, 218.36850733},
{210.5, 215.54873869},
{211.5, 212.68666461},
{212.6, 209.99372274},
{213.6, 207.26711154},
{214.5, 204.64072868},
{215.4, 202.04282230},
{216.3, 199.51922894},
{217.2, 197.04086781},
{218.0, 194.60499287},
{218.8, 192.20974445},
{219.6, 189.87672329},
{220.3, 187.53368855},
{221.1, 185.31825542},
{221.8, 183.09051991},
{222.5, 180.91785908},
{223.2, 178.79827023},
{223.9, 176.73003674},
{224.6, 174.71144199},
{225.3, 172.74091244},
{226.0, 170.77395916},
{226.6, 168.87638569},
{227.3, 167.04032421},
{227.9, 165.18580914},
{228.6, 163.42942715},
{229.2, 161.65115833},
{229.9, 159.96415615},
{230.5, 158.25669765},
{231.2, 156.64522648},
{231.9, 155.04648685},
{232.5, 153.50325108},
{233.2, 152.03397274},
{233.8, 150.56526661},
{234.5, 149.20427799},
{235.2, 147.89893627},
{235.9, 146.60975933},
{236.5, 145.40584087},
{237.2, 144.26672459},
{237.9, 143.18082333},
{238.6, 142.14627743},
{239.3, 141.16165638},
{240.0, 140.21666050},
{240.7, 139.31801319},
{241.4, 138.48187923},
{242.1, 137.68765926},
{242.8, 136.92791462},
{241.3, 135.19356251},
{239.6, 133.45963955},
{238.0, 131.80453777},
{236.4, 130.19979000},
{234.9, 128.68788242},
{233.4, 127.22232342},
{232.0, 125.84559917},
{230.5, 124.46815968},
{229.1, 123.17626476},
{227.8, 121.96834087},
{226.5, 120.76056004},
{225.1, 119.62487698},
{223.9, 118.55971813},
{222.6, 117.51487255},
{221.4, 116.53368473},
{220.2, 115.56522846},
{219.0, 114.67173100},
{217.8, 113.78924847},
{216.6, 112.93809414},
{215.5, 112.16005906},
{214.4, 111.41187906},
{213.3, 110.69286498},
{212.2, 110.00264114},
{211.2, 109.36140490},
{210.1, 108.74835464},
{209.1, 108.18294731},
{208.0, 107.60273695},
{207.0, 107.09074169},
{206.0, 106.60479963},
{205.1, 106.14490893},
{204.1, 105.74862376},
{203.1, 105.34173408},
{202.1, 104.95671609},
{201.2, 104.63853014},
{200.3, 104.31928071},
{199.3, 104.03320822},
{198.4, 103.78809214},
{197.5, 103.56704697},
{196.6, 103.37002510},
{195.7, 103.19068894},
{194.8, 103.04392684},
{193.9, 102.92294827},
{193.0, 102.82171458},
{192.1, 102.74458596},
{191.2, 102.69148421},
{190.4, 102.67266178},
{189.5, 102.70182386},
{188.6, 102.72178417},
{187.7, 102.76630118},
{186.9, 102.88040194},
{186.0, 102.97496617},
{185.2, 103.11150324},
{184.3, 103.28570953},
{183.4, 103.45729679},
{182.6, 103.70140988},
{181.7, 103.92608270},
{180.9, 104.20191702},
{180.0, 104.50442433},
{179.1, 104.81208757},
{178.3, 105.19627348},
{177.4, 105.56197613},
{176.6, 105.96600121},
{175.7, 106.43246862},
{174.8, 106.88985384},
{173.9, 107.37897822},
{173.1, 107.92351922},
{172.2, 108.50531906},
{171.3, 109.09739873},
{170.4, 109.72300172},
{169.5, 110.38498297},
{168.6, 111.08452588},
{167.7, 111.82266524},
{166.8, 112.60063112},
{165.9, 113.40354422},
{165.0, 114.22805876},
{164.0, 115.13084054},
{163.1, 116.06457493},
{162.1, 117.02136138},
{161.2, 118.04016054},
{160.2, 119.10500604},
{159.2, 120.19340968},
{158.2, 121.33498234},
{157.2, 122.53188479},
{156.2, 123.78641874},
{155.2, 125.10112762},
{154.2, 126.47379559},
{153.1, 127.85390279},
{152.1, 129.36003837},
{151.0, 130.87566942},
{149.9, 132.45962557},
{149.9, 133.17721167},
{150.5, 133.38209078},
{151.1, 133.62216511},
{151.8, 133.91942972},
{152.4, 134.26640832},
{153.0, 134.62487608},
{153.6, 135.00670767},
{154.3, 135.49015471},
{154.9, 135.94833395},
{155.6, 136.50864089},
{156.3, 137.05154434},
{156.9, 137.66946772},
{157.6, 138.34116817},
{158.3, 139.05099288},
{159.0, 139.79936868},
{159.7, 140.58683190},
{160.4, 141.41414034},
{161.2, 142.34733379},
{161.9, 143.26176837},
{162.7, 144.28379062},
{163.5, 145.33611014},
{164.3, 146.43624231},
{165.1, 147.61089858},
{165.9, 148.81173572},
{166.8, 150.08404076},
{167.6, 151.42537653},
{168.5, 152.84207985},
{169.4, 154.30941445},
{170.4, 155.83774495},
{171.3, 157.47546235},
{172.3, 159.17745331},
{173.3, 160.93608013},
{174.3, 162.75289258},
{175.4, 164.70516759},
{176.5, 166.71933398},
{177.6, 168.79718113},
{178.8, 171.01747763},
{180.0, 173.30578208},
{181.3, 175.66360053},
{182.5, 178.17143753},
{183.9, 180.81732461},
{185.3, 183.51888093},
{186.7, 186.38873300},
{188.2, 189.36775357},
{189.7, 192.42986974},
{191.4, 195.67156810},
{193.0, 199.06075805},
{194.8, 202.63661730},
{196.6, 206.30528563},
{198.5, 210.15382931},
{200.5, 214.18532327},
{202.6, 218.40280968},
{204.8, 222.80874109},
{207.1, 227.40549180},
{205.2, 228.30188692},
{203.3, 229.14131358},
{201.3, 230.01380834},
{199.5, 231.00752905},
{197.7, 231.94044712},
{195.9, 232.97519812},
{194.2, 233.94147652},
{192.5, 235.03832713},
{190.8, 236.11314261},
{189.2, 237.21984708},
{187.7, 238.30530134},
{186.1, 239.46539548},
{184.7, 240.62183198},
{183.2, 241.82640767},
{181.8, 243.02579302},
{180.5, 244.30999503},
{179.2, 245.53073740},
{177.9, 246.79649672},
{176.7, 248.08572820},
{175.5, 249.30276141},
{174.9, 248.62494072}
};

__CONSTANT__ float3 surround = {0.9, 0.59, 0.9};

__CONSTANT__ float3 d65White = {95.05f, 100.0f, 108.88f};

// ST2084 constants
__CONSTANT__ float st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);
__CONSTANT__ float st2084_m_2=2523.0f / 4096.0f * 128.0f;
__CONSTANT__ float st2084_c_1=3424.0f / 4096.0f;
__CONSTANT__ float st2084_c_2=2413.0f / 4096.0f * 32.0f;
__CONSTANT__ float st2084_c_3=2392.0f / 4096.0f * 32.0f;
__CONSTANT__ float st2084_m_1_d = 1.0f / st2084_m_1;
__CONSTANT__ float st2084_m_2_d = 1.0f / st2084_m_2;
__CONSTANT__ float st2084_L_p = 10000.0f;

// multiplies a 3D vector with a 3x3 matrix
__DEVICE__ float3 vector_dot( float3x3 m, float3 v)
{
    float3 r;

    r.x = m.x.x * v.x + m.x.y * v.y + m.x.z * v.z;
    r.y = m.y.x * v.x + m.y.y * v.y + m.y.z * v.z;
    r.z = m.z.x * v.x + m.z.y * v.y + m.z.z * v.z;
    
    return r;
}

// "safe" power function to avoid NANs or INFs when taking a fractional power of a negative base
// this one initially returned -pow(abs(b), e) for negative b
// but this ended up producing undesirable results in some cases
// so now it just returns 0.0 instead
__DEVICE__ float spow( float base, float exponent )
{
    if(base < 0.0f && exponent != _floorf(exponent) )
    {
         return 0.0f;
    }
    else
    {
        return _powf(base, exponent); 
    }
}

__DEVICE__ float3 float3spow( float3 base, float exponent )
{
    return make_float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));
}

__DEVICE__ float3 float3sign( float3 v )
{
    return make_float3(_copysignf(1.0f, v.x), _copysignf(1.0f, v.y), _copysignf(1.0f, v.z));
}

__DEVICE__ float3 float3abs( float3 a )
{
    return make_float3(_fabs(a.x), _fabs(a.y), _fabs(a.z));
}

// "safe" div
__DEVICE__ float sdiv( float a, float b )
{
    if(b == 0.0f)
    {
        return 0.0f;
    }
    else
    {
        return a / b;
    }
}

// linear interpolation between two values a & b with the bias t
__DEVICE__ float lerp(float a, float b, float t)
{
    return a + t * (b - a);
}

// convert radians to degrees
__DEVICE__ float radians_to_degrees( float radians )
{
    return radians * 180.0f / PI;
}


// convert degrees to radians
__DEVICE__ float degrees_to_radians( float degrees )
{
    return degrees / 180.0f * PI;
}

__DEVICE__ float mod(float a, float N)
{
    return a - N * _floorf(a / N);
}

__DEVICE__ float3 compress(float3 xyz)
{
    float x = xyz.x;
    float y = xyz.y;
    float z = xyz.z;
   
    float C = (x + y + z) / 3.0f;
    if (C == 0.0f)
        return xyz;

    float R = _sqrtf((x-C)*(x-C) + (y-C)*(y-C) + (z-C)*(z-C));
    R = R * 0.816496580927726f; // np.sqrt(2/3)
    
    if (R != 0.0f)
    {
      x = (x - C) / R;
      y = (y - C) / R;
      z = (z - C) / R;
    }
      
    float r = R / C;
    float s = -_fminf(x, _fminf(y, z));
    
    float t = 0.0f;
    if (r != 0.0f)
    {
      t = (0.5f + spow((_powf((s - 0.5f), 2.0f) + _powf((_sqrtf(4.0f / _powf(r, 2.0f) + 1.0f) - 1.0f), 2.0f) / 4.0f), 0.5f));
      if (t == 0.0f)
        return make_float3(xyz.x, xyz.y, xyz.z);
      t = 1.0f / t;
    }

    x = C * x * t + C;
    y = C * y * t + C;
    z = C * z * t + C;

    return make_float3(x, y, z);
}

__DEVICE__ float3 uncompress(float3 xyz)
{
    float x = xyz.x;
    float y = xyz.y;
    float z = xyz.z;

    float C = (x+y+z)*(1.0f / 3.0f) ;
    if (C == 0.0f)
         return xyz;

    float R = _sqrtf(_powf(_fabs(x-C), 2.0f) + _powf(_fabs(y-C), 2.0f) + _powf(_fabs(z-C), 2.0f));
    R = R * 0.816496580927726; // np.sqrt(2/3)
    
    if (R != 0.0f)
    {
        x = (x - C) / R;
        y = (y - C) / R;
        z = (z - C) / R;
    }

    float t = R / C;
    float s = -_fminf(x, _fminf(y, z));
    
    float r = 0.0f;
    if (t != 0.0f)
    {
         r = _sqrtf(_powf((2.0f * _sqrtf(_powf((1.0f / t - 0.5f),2.0f) - _powf((s - 0.5f), 2.0f)) + 1.0f), 2.0f) - 1.0f);
         if (r == 0.0f)
            return make_float3(xyz.x, xyz.y, xyz.z);
         r = 2.0f / r;
    }

    x = C * x * r + C;
    y = C * y * r + C;
    z = C * z * r + C;
    
    return make_float3(x, y, z);
}

// "PowerP" compression function (also used in the ACES Reference Gamut Compression)
// values of v above  'threshold' are compressed by a 'power' function
// so that an input value of 'limit' results in an output of 1.0
__DEVICE__ float compressPowerP( float v, float threshold, float limit, float power, int inverse )
{
    float s = (limit-threshold)/_powf(_powf((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);

    float vCompressed;

    if( inverse )
    {
        vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*_powf(-(_powf((v-threshold)/s,power)/(_powf((v-threshold)/s,power)-1.0f)),1.0f/power);
    }
    else
    {
        vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(_powf(1.0f+_powf((v-threshold)/s,power),1.0f/power));
    }

    return vCompressed;
}

__DEVICE__ float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)
{
    float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);
    float3 RGB_c;
    RGB_c.x = (400.0f * _copysignf(1.0f, RGB.x) * F_L_RGB.x) / (27.13f + F_L_RGB.x) + 0.1f;
    RGB_c.y = (400.0f * _copysignf(1.0f, RGB.y) * F_L_RGB.y) / (27.13f + F_L_RGB.y) + 0.1f;
    RGB_c.z = (400.0f * _copysignf(1.0f, RGB.z) * F_L_RGB.z) / (27.13f + F_L_RGB.z) + 0.1f;

    return RGB_c;
}

__DEVICE__ float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)
{
    float3 RGB_p =  (float3sign(RGB - 0.1f) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB - 0.1f)) / (400.0f - float3abs(RGB - 0.1f)), 1.0f / 0.42f) );

    return RGB_p;
}

__DEVICE__ float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w)
{
    float Y_w = XYZ_w.y ;

    // # Step 0
    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.
    float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);

    // Ignore degree of adaptation.
    // If we always do this, some of the subsequent code can be simplified
    float D = 1.0f;

    // # Viewing conditions dependent parameters
    float k = 1.0f / (5.0f * L_A + 1.0f);
    float k4 = _powf(k,4);
    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * _powf((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;
    float n = sdiv(Y_b, Y_w);
    float z = 1.48f + _sqrtf(n);

    float3 D_RGB = D * Y_w / RGB_w + 1.0f - D;
    float3 RGB_wc = D_RGB * RGB_w;

    // # Applying forward post-adaptation non-linear response compression.
    float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);

    // # Computing achromatic responses for the whitepoint.
    float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB) + 0.1f;

    // # Computing achromatic responses for the whitepoint.
    float R_aw = RGB_aw.x ;
    float G_aw = RGB_aw.y ;
    float B_aw = RGB_aw.z ;
    float A_w = 2.0f * R_aw + G_aw + 0.05f * B_aw - 0.305f;

    // # Step 1
    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.

    float3 RGB = vector_dot(MATRIX_16, XYZ);

    // # Step 2
    float3 RGB_c = D_RGB * RGB;

    // # Step 3
    // Always compressMode
    RGB_c = compress(RGB_c);

    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);

    RGB_a = uncompress(RGB_a);

    // # Step 4
    // # Converting to preliminary cartesian coordinates.
    float R_a = RGB_a.x ;
    float G_a = RGB_a.y ;
    float B_a = RGB_a.z ;
    float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;
    float b = (R_a + G_a - 2.0f * B_a) / 9.0f;

    // # Computing the *hue* angle :math:`h`.
    // Unclear why this isnt matching the python version.
    float h = mod(radians_to_degrees(_atan2f(b, a)), 360.0f);

    // # Step 6
    // # Computing achromatic responses for the stimulus.
    float R_a2 = RGB_a.x ;
    float G_a2 = RGB_a.y ;
    float B_a2 = RGB_a.z ;
    // A = 2 * R_a + G_a + 0.05 * B_a - 0.305
    float A = 2.0f * R_a2 + G_a2 + 0.05f * B_a2 - 0.305f;

    // # Step 7
    // # Computing the correlate of *Lightness* :math:`J`.
    // with sdiv_mode():
    float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);

    // # Step 9
    // # Computing the correlate of *colourfulness* :math:`M`.
    float M = 43.0f * surround.z * _sqrtf(a * a + b * b);

    // Np *Helmholtz–Kohlrausch* Effect Extension.

    if (J == 0.0f)
    {
        M = 0.0f;
    }
      return make_float3(J, M, h);
}

__DEVICE__ float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w)
{
    float J = JMh.x;
    float M = JMh.y;
    float h = JMh.z;

    float Y_w = XYZ_w.y;

    // # Step 0
    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.
    float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);

    // Ignore degree of adaptation.
    // If we always do this, some of the subsequent code can be simplified
    float D = 1.0f;

    // # Viewing conditions dependent parameters
    float k = 1.0f / (5.0f * L_A + 1.0f);
    float k4 = _powf(k, 4.0f);
    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * _powf((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;
    float n = sdiv(Y_b, Y_w);
    float z = 1.48f + _sqrtf(n);

    float3 D_RGB = D * Y_w / RGB_w + 1.0f - D;
    float3 RGB_wc = D_RGB * RGB_w;

    // # Applying forward post-adaptation non-linear response compression.
    float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);

    // # Computing achromatic responses for the whitepoint.
    float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB) + 0.1f;

    // # Computing achromatic responses for the whitepoint.
    float R_aw = RGB_aw.x ;
    float G_aw = RGB_aw.y ;
    float B_aw = RGB_aw.z ;
    float A_w = 2.0f * R_aw + G_aw + 0.05f * B_aw - 0.305f;

    float hr = degrees_to_radians(h);

    // No *Helmholtz–Kohlrausch* Effect.

    // # Computing achromatic response :math:`A` for the stimulus.
    float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));

    // # Computing *P_p_1* to *P_p_2*.
    float P_p_1 = 43.0f * surround.z;
    float P_p_2 = A;


    // # Step 3
    // # Computing opponent colour dimensions :math:`a` and :math:`b`.
    // with sdiv_mode():
    float gamma = M / P_p_1;

    float a = gamma * _cosf(hr);
    float b = gamma * _sinf(hr);


    // # Step 4
    // # Applying post-adaptation non-linear response compression matrix.

    float3 RGB_a = vector_dot(panlrcm, make_float3(P_p_2, a, b)) / 1403.0f;

    // # Step 5
    // # Applying inverse post-adaptation non-linear response compression.

    // Always compressMode
    RGB_a = compress(RGB_a);

    float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a + 0.1f, F_L);

    RGB_c = uncompress(RGB_c);

    // # Step 6
    float3 RGB = RGB_c / D_RGB;
    

    // # Step 7
    float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);

    return XYZ;
}

// convert JMh correlates to  RGB values in the output colorspace
__DEVICE__ float3 JMh_to_luminance_RGB(float3 JMh)
{
    float3 luminanceXYZ = Hellwig2022_JMh_to_XYZ( JMh, d65White);
    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);

    return luminanceRGB;
}

// convert RGB values in the output colorspace to the Hellwig J (lightness), M (colorfulness) and h (hue) correlates
__DEVICE__ float3 luminance_RGB_to_JMh(float3 luminanceRGB)
{
    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);
    float3 JMh = XYZ_to_Hellwig2022_JMh(XYZ, d65White);
    return JMh;
}

__DEVICE__ float daniele_evo_fwd(float Y)
{
    const float daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (_logf(daniele_n / daniele_n_r) / _logf(10000.0f / 100.0f));
    const float daniele_m_0 = daniele_n / daniele_n_r;
    const float daniele_m_1 = 0.5f * (daniele_m_0 + _sqrtf(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));
    const float daniele_u = _powf((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);
    const float daniele_m = daniele_m_1 / daniele_u;
    const float daniele_w_i = _logf(daniele_n / 100.0f) / _logf(2.0f);
    const float daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;
    const float daniele_g_ip = 0.5f * (daniele_c_t + _sqrtf(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));
    const float daniele_g_ipp2 = -daniele_m_1 * _powf(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (_powf(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);
    const float daniele_w_2 = daniele_c / daniele_g_ipp2;
    const float daniele_s_2 = daniele_w_2 * daniele_m_1;
    const float daniele_u_2 = _powf((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);
    const float daniele_m_2 = daniele_m_1 / daniele_u_2;

    float f = daniele_m_2 * _powf(_fmaxf(0.0f, Y) / (Y + daniele_s_2), daniele_g);
    float h = _fmaxf(0.0f, f * f / (f + daniele_t_1));

    return h;
}

__DEVICE__ float ptanh(float x, float p, float t, float pt)
{
    return _powf(_tanhf(_powf(x, p) / t), 1.0f / pt);
}

// convert linear RGB values with the limiting primaries to Hellwig J (lightness), M (colorfulness) and h (hue) correlates
// __DEVICE__ float3 limit_RGB_to_JMh(float3 RGB)
// {
//     float3 luminanceRGB = RGB * boundaryRGB * referenceLuminance;
//     float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);
//     float3 JMh = XYZ_to_Hellwig2022_JMh(XYZ, d65White);
//     return JMh;
// }

// Scaled power(p)
__DEVICE__ float spowerp(float x, float l, float p)
{
    x = x / l;
    x = x != 0.0f ? x / _powf(1.0f + spow(x, p), 1.0f / p) : 0.0f;
    return x * l;
}

__DEVICE__ float desat_curve(float x)
  {
    float m = daniele_n / daniele_n_r;
    float w = 1.18f * m;
    return (_fmaxf(0.0f, x) / (x + w)) * m;
  }

  // Hue-dependent curve used in chroma compression
  // https://www.desmos.com/calculator/lmbbu8so4c
__DEVICE__ float compr_hue_depend(float h)
{
    float hr = degrees_to_radians(h);
    float hr2 = hr * 2.0f;
    float hr3 = hr * 3.0f;

    return (a.x * _cosf(hr) +
            b.x * _cosf(hr2) +
            c.x * _cosf(hr3) +
            a.y * _sinf(hr) +
            b.y * _sinf(hr2) +
            c.y * _sinf(hr3) +
            hoff) * hmul;
}

  // Chroma compression
  //
  // - Compresses the scene colorfulness with desat_curve() and spowerp() for
  //   path-to-white and path-to-black.
  // - Scales the colorfulness with a cubic curve to affect the rate of change of
  //   desaturation as lightness is increased.  This is hue dependent and affects
  //   a range of colorfulness (distance from the achromatic).
  //
__DEVICE__ float chromaCompression(float3 JMh, float luminance, int invert)
{
    float M = JMh.y;

    // Model specific factors to avoid having to change parameters manually
    int camMode = 1;
    float model_desat_factor = camMode == 1 ? chromaCompress * 1.22f : chromaCompress * 0.8f;
    float model_factor = camMode == 1 ? 5.0f : 1.0f;

    // Path-to-white
    //
    // Compression curve based on the difference of the scene luminance and desat_curve().
    // This scales automatically, compressing less with higher peak luminance.  Higher peak
    // luminance has a slower rate of change for colorfulness so it needs less compression.
    // The end variable can be used to affect how close to white point the curve ends, and
    // prevents the curve ever going negative.
    // https://www.desmos.com/calculator/ovy5wzr7lm
    //
    float end = 0.12f;
    float x = _log10f(luminance) - _log10f(desat_curve(luminance));
    model_desat_factor += _logf(daniele_n / daniele_n_r) * 0.08f;
    float desatcurve = spowerp(x * model_desat_factor, chromaCompressParams.x, chromaCompressParams.y);
    desatcurve = desatcurve < (1.0f - end) ? desatcurve : (1.0f - end) + end * _tanhf((desatcurve - (1.0f - end)) / end);

    // Path-to-black
    //
    // Shadow compression to reduce clipPIng and colorfulness of noise.
    // https://www.desmos.com/calculator/ovy5wzr7lm
    //
    float shadowcurve = ptanh(luminance, shadowCompressParams.x, shadowCompressParams.y, shadowCompressParams.z);
    if (isnan(shadowcurve))
    {
        shadowcurve = 1.0f;
    }

    // In-gamut compression
    //
    // Hue-dependent compression of M with R (J) from achromatic outward.  The purpose is to make sure
    // the interior of the gamut is smooth and even.  Larger values of R will compress larger range of
    // colorfulness.  The c variable controls compression with R (1.0 no compression, 0.0001 full
    // compression).  The driver is the tonescaled lightness in 0-1 range.  The shadow_boost affects
    // saturation mainly at and under normal exposure.
    // https://www.desmos.com/calculator/nygtri388c
    //
    float R = (JMh.x + 0.01f) * model_factor * compr_hue_depend(JMh.z);
    float c = _fmaxf(1.0f - (JMh.x / limitJmax), 0.0001f) * shadow_boost;

    desatcurve = (1.0f - desatcurve) * shadowcurve;

    if (!invert)
    {
      M *= desatcurve;
      if (M != 0.0f && R != 0.0f)
      {
        M *= ((M * M + R * c) / (M * M + R));
      }
      M *= sat;
    }
    else
    {
      M /= sat;
      if (M != 0.0f && R != 0.0f)
      {
        float t0 = 3.0f * R * c;
        float p0 = M * M - t0;
        float p1 = 2.0f * M * M + 27.0f * R - 3.0f * t0;
        float p2 = spow((_sqrtf(M * M * p1 * p1 - 4.0f * p0 * p0 * p0) / 2.0f) + M * p1 / 2.0f, 1.0f / 3.0f);
        M = (p0 / (3.0f * p2) + (p2 / 3.0f) + (M / 3.0f));
      }
      M /= desatcurve;
    }

    return M;
}

__DEVICE__ float3 forwardTonescale( float3 inputJMh, int compressChroma)
{
    float3 outputJMh;
    float3 monoJMh = make_float3(inputJMh.x,0.0f,0.0f);
    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);
    float linear = linearJMh.x / referenceLuminance;

    // only Daniele Evo tone scale
    float luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;

    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(make_float3(luminanceTS,luminanceTS,luminanceTS));
    float3 tonemappedJMh = make_float3(tonemappedmonoJMh.x, inputJMh.y, inputJMh.z);

    outputJMh = tonemappedJMh;

    // Chroma Compression)
    if (compressChroma)
    {
        outputJMh.y = chromaCompression(outputJMh, linear, 0);
    }

    return outputJMh;
}

__DEVICE__ float2 cuspFromTable(float h)
{
    int lo = (int)_floorf(mod(h, 360.0f));
    int hi = (int)_ceilf(mod(h, 360.0f));
    if (hi == 360)
    {
        hi = 0;
    }
    float t = _fmod(h, 1.0f);
    float2 out;
    out.x = lerp(gamutCuspTable[lo].x, gamutCuspTable[hi].x, t);
    out.y = lerp(gamutCuspTable[lo].y, gamutCuspTable[hi].y, t);

    return out;
}

// Smooth minimum of a and b
__DEVICE__ float smin(float a, float b, float s)
{
    float h = _fmaxf(s - _fabs(a - b), 0.0f) / s;
    return _fminf(a, b) - h * h * h * s * (1.0f / 6.0f);
}

// Approximation of the gamut intersection to a curved and smoothened triangle
// along the projection line 'from -> to'. 
__DEVICE__ float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)
{
    float t0, t1;

    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce
    // smoothing for high cusps because smin() will bias it too much for the longer line.
    float s = _fmaxf(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);
    cusp.y += 15.0f * s;
    cusp.x += 5.0f * s;

    // Line below the cusp is curved with gamut_gamma
    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);
    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);
    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));

    // Line above the cusp
    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));

    // Smooth minimum to smooth the cusp
    t1 = smin(_fabs(t0), _fabs(t1), s);

    return make_float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);
}

__DEVICE__ float3 compressGamut(float3 JMh, int invert)
{
    float2 project_from = make_float2(JMh.x, JMh.y);
    float2 JMcusp = cuspFromTable(JMh.z);

    if (project_from.y == 0.0f)
      return JMh;

    // Calculate where the out of gamut color is projected to
    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);

    // https://www.desmos.com/calculator/9u0wiiz9ys
    float Mratio = project_from.y / (focusDistance * JMcusp.y);
    float a = _fmaxf(0.001f, Mratio / focusJ);
    float b0 = 1.0f - Mratio;
    float b1 = -(1.0f + Mratio + (a * limitJmax));
    float b = project_from.x < focusJ ? b0 : b1;
    float c0 = -project_from.x;
    float c1 = project_from.x + limitJmax * Mratio;
    float c = project_from.x < focusJ ? c0 : c1;

    float J0 = _sqrtf(b * b - 4.0f * a * c);
    float J1 = (-b - J0) / (2.0f * a);
          J0 = (-b + J0) / (2.0f * a);
    float projectJ = project_from.x < focusJ ? J0 : J1;

    // Find gamut intersection
    float2 project_to = make_float2(projectJ, 0.0f);
    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);

    // Compress the out of gamut color along the projection line
    float v = project_from.y / JMboundary.y;
    v = compressPowerP(v, compressionFuncParams.x, lerp(compressionFuncParams.z, compressionFuncParams.y, projectJ / limitJmax), compressionFuncParams.w, invert);
    float2 JMcompressed = project_to + v * (JMboundary - project_to);

    return make_float3(JMcompressed.x, JMcompressed.y, JMh.z);
}

  // encode linear values as ST2084 PQ
__DEVICE__ float linear_to_ST2084( float v )
{
    float Y_p = spow(_fmaxf(0.0f, v) / st2084_L_p, st2084_m_1);

    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B)
{
    float3 in = make_float3(p_R, p_G, p_B);
    float3 out = in;
    in.x = _clampf(in.x, -65504.0f, 65504.0f);
    in.y = _clampf(in.y, -65504.0f, 65504.0f);
    in.z = _clampf(in.z, -65504.0f, 65504.0f);

    float3 XYZ = vector_dot(AP0_ACES_to_XYZ_matrix, in);
    XYZ *= referenceLuminance;
    float3 inWhite = vector_dot(AP0_ACES_to_XYZ_matrix, make_float3(100.0f, 100.0f, 100.0f));
    float3 JMh = XYZ_to_Hellwig2022_JMh(XYZ, inWhite);
    if (toneCurve)
    {
        JMh = forwardTonescale(JMh, compressChroma);
    }
    if (gamutCompress)
    {
        JMh = compressGamut(JMh, 0);
    }
    if (JMhOut)
    {
        out.x = JMh.x / referenceLuminance;
        out.y = JMh.y / referenceLuminance;
        out.z = JMh.z / 360.0f;
    }
    else
    {
        XYZ = Hellwig2022_JMh_to_XYZ(JMh , d65White) / referenceLuminance;
        out = vector_dot(XYZ_to_RGB_output, XYZ);
//         out = float3spow(out, 1.0f / 2.4f);
        out.x = linear_to_ST2084(out.x * 100.0f);
        out.y = linear_to_ST2084(out.y * 100.0f);
        out.z = linear_to_ST2084(out.z * 100.0f);
    }

    return out ;
}